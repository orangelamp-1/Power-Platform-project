// =============================================================================
// Jenkinsfile.deploy — GitHub Repository → Test → Production
// =============================================================================
// Purpose:
//   Manually triggered pipeline that checks out the solution source from the repo,
//   packs a Managed zip, and deploys it to Test and/or Production.
//
// Trigger:   Manual (Build with Parameters in Jenkins)
// Agent:     Windows — PowerShell
//
// Parameters:
//   DEPLOY_TARGET = "test"       → pack + deploy Managed to Test only
//   DEPLOY_TARGET = "Production" → pack + deploy Managed to Test, then prompt
//                                  for manual approval before deploying to Prod
//
// Flow:
//   1. Checkout      – pull latest main
//   2. Validate      – XML validation of all solution files
//   3. Pack          – build Managed zip from source
//   4. Deploy Test   – import Managed into Test environment
//   5. Approve Prod  – manual sign-off (production target only)
//   6. Deploy Prod   – import Managed into Production (production target only)
// =============================================================================

pipeline {

    agent { label 'windows' }

    parameters {
        choice(
            name: 'DEPLOY_TARGET',
            choices: ['Test', 'Production'],
            description: 'Choose "Test" to deploy to Test only. Choose "Production" to deploy to Test then prompt for Production approval.'
        )
        booleanParam(
            name: 'STAGE_AND_UPGRADE',
            defaultValue: false,
            description: 'Import using stage-and-upgrade instead of a direct overwrite. Use when upgrading to a new solution version.'
        )
        booleanParam(
            name: 'FORCE_OVERWRITE',
            defaultValue: false,
            description: 'Force overwrite of unmanaged customisations in the target environment. Slow — only enable when needed.'
        )
    }

    environment {
        SOLUTION_NAME    = 'OL_MAIN'
        SOLUTION_SRC     = 'src/solution'
        BUILD_DIR        = 'build'

        // Environment URLs — stored as Jenkins credentials
        TEST_ENV_URL     = credentials('dataverse-test-url')
        PROD_ENV_URL     = credentials('dataverse-prod-url')

        // Service Principal — stored as Jenkins credentials
        TENANT_ID        = credentials('dataverse-tenant-id')
        CLIENT_ID        = credentials('dataverse-client-id')
        CLIENT_SECRET    = credentials('dataverse-client-secret')
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '20'))
        timeout(time: 60, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }

    stages {

        // ─── Stage 1: Checkout ────────────────────────────────────────────────
        stage('Checkout') {
            steps {
                echo '=== Checking out main branch ==='
                checkout scm
                powershell 'git log -1 --pretty=format:"%h — %s (%an, %ar)"'
            }
        }

        // ─── Stage 2: Validate ────────────────────────────────────────────────
        stage('Validate') {
            steps {
                echo '=== Validating solution XML ==='
                powershell """
                    \$ErrorActionPreference = 'Stop'

                    function Test-Xml {
                        param([string]\$Path)
                        try {
                            \$xml = New-Object System.Xml.XmlDocument
                            \$xml.Load((Resolve-Path \$Path))
                            Write-Host "  OK: \$Path"
                        } catch {
                            throw "Invalid XML in \$Path : \$_"
                        }
                    }

                    Write-Host '>> Solution.xml'
                    Test-Xml '${SOLUTION_SRC}/Other/Solution.xml'

                    Write-Host '>> Customizations.xml'
                    Test-Xml '${SOLUTION_SRC}/Other/Customizations.xml'

                    Write-Host '>> Entity definitions'
                    Get-ChildItem -Path '${SOLUTION_SRC}/Entities' -Recurse -Filter '*.xml' | ForEach-Object {
                        Test-Xml \$_.FullName
                    }

                    Write-Host 'All XML files valid.'
                """
            }
            post {
                failure {
                    error 'XML validation failed — fix errors in the solution source before deploying.'
                }
            }
        }

        // ─── Stage 3: Pack Managed ────────────────────────────────────────────
        stage('Pack') {
            steps {
                echo '=== Packing Managed solution from source ==='
                powershell """
                    New-Item -ItemType Directory -Force -Path '${BUILD_DIR}' | Out-Null
                    pac solution pack `
                        --folder '${SOLUTION_SRC}' `
                        --zipfile '${BUILD_DIR}\\${SOLUTION_NAME}_managed.zip' `
                        --packagetype Managed
                    Get-ChildItem '${BUILD_DIR}'
                """
            }
            post {
                success {
                    archiveArtifacts artifacts: "build\\*.zip", fingerprint: true
                }
            }
        }

        // ─── Stage 4: Deploy to Test ──────────────────────────────────────────
        stage('Deploy Test') {
            steps {
                echo '=== Deploying Managed solution to Test ==='
                powershell """
                    pac auth create `
                        --environment "\$env:TEST_ENV_URL" `
                        --tenant "\$env:TENANT_ID" `
                        --applicationId "\$env:CLIENT_ID" `
                        --clientSecret "\$env:CLIENT_SECRET" `
                        --name TestEnvironment
                    pac auth select --name TestEnvironment
                    \$upgradeFlag = if ('${params.STAGE_AND_UPGRADE}' -eq 'true') { '--stage-and-upgrade' } else { '' }
                    \$overwriteFlag = if ('${params.FORCE_OVERWRITE}' -eq 'true') { '--force-overwrite' } else { '' }
                    pac solution import `
                        --path '${BUILD_DIR}\\${SOLUTION_NAME}_managed.zip' `
                        --activate-plugins `
                        \$upgradeFlag `
                        \$overwriteFlag
                    Write-Host 'Test deployment complete.'
                """
            }
            post {
                success { echo '✅ Test environment updated successfully.' }
                failure { error '❌ Test deployment failed — Production gate will not open.' }
            }
        }

        // ─── Stage 5: Production Approval Gate ────────────────────────────────
        stage('Approve Production') {
            when {
                expression { return params.DEPLOY_TARGET == 'Production' }
            }
            options {
                timeout(time: 24, unit: 'HOURS')
            }
            steps {
                script {
                    def releaseNotes = input(
                        message: 'Deploy Managed solution to Production?',
                        ok: 'Approve & Deploy to Production',
                        submitter: 'release-managers',
                        parameters: [
                            string(
                                name: 'RELEASE_NOTES',
                                defaultValue: '',
                                description: 'Release notes for this production deployment'
                            )
                        ]
                    )
                    env.RELEASE_NOTES = releaseNotes ?: ''
                }
                echo "=== Production deployment approved ==="
                echo "Release notes: ${env.RELEASE_NOTES}"
            }
        }

        // ─── Stage 6: Deploy to Production ────────────────────────────────────
        stage('Deploy Prod') {
            when {
                expression { return params.DEPLOY_TARGET == 'Production' }
            }
            steps {
                echo '=== Deploying Managed solution to Production ==='
                powershell """
                    pac auth create `
                        --environment "\$env:PROD_ENV_URL" `
                        --tenant "\$env:TENANT_ID" `
                        --applicationId "\$env:CLIENT_ID" `
                        --clientSecret "\$env:CLIENT_SECRET" `
                        --name ProdEnvironment
                    pac auth select --name ProdEnvironment
                    \$upgradeFlag = if ('${params.STAGE_AND_UPGRADE}' -eq 'true') { '--stage-and-upgrade' } else { '' }
                    \$overwriteFlag = if ('${params.FORCE_OVERWRITE}' -eq 'true') { '--force-overwrite' } else { '' }
                    pac solution import `
                        --path '${BUILD_DIR}\\${SOLUTION_NAME}_managed.zip' `
                        --activate-plugins `
                        \$upgradeFlag `
                        \$overwriteFlag
                    Write-Host 'Production deployment complete.'
                """
            }
            post {
                success { echo '✅ Production deployment successful.' }
                failure { echo '❌ Production deployment failed — investigate before retrying.' }
            }
        }
    }

    post {
        success {
            echo '✅ Pipeline complete.'
        }
        failure {
            echo '❌ Pipeline failed. Check stage logs. Production was NOT updated.'
        }
        aborted {
            echo '⚠️ Pipeline aborted — Production approval may have timed out or been rejected.'
        }
        always {
            cleanWs(deleteDirs: true, notFailBuild: true)
        }
    }
}
